"use strict";(self.webpackChunkskydev=self.webpackChunkskydev||[]).push([[9987],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>h});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(r),h=a,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||o;return r?n.createElement(m,i(i({ref:t},d),{},{components:r})):n.createElement(m,i({ref:t},d))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"},6968:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=r(7462),a=(r(7294),r(3905));const o={sidebar_position:9},i=void 0,s={unversionedId:"DSA/BFS_DFS",id:"DSA/BFS_DFS",title:"BFS_DFS",description:"Introduction",source:"@site/docs/DSA/BFS_DFS.md",sourceDirName:"DSA",slug:"/DSA/BFS_DFS",permalink:"/Skydev/docs/DSA/BFS_DFS",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Backtracking",permalink:"/Skydev/docs/DSA/Backtrack"},next:{title:"Dynamic Programming",permalink:"/Skydev/docs/DSA/Dynamic_Programming"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Resources",id:"resources",level:2},{value:"Questions",id:"questions",level:2}],d={toc:p};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"These are techniques for finding something. It applies to arrays, graphs, trees, and so on. Many people mistake this for something related to graphs, but it is simply a technique for solving a generic search problem.\nHere\u2019s a great visualizer tool: ",(0,a.kt)("a",{parentName:"p",href:"https://visualgo.net/en/dfsbfs"},"Graph Traversal (Depth/Breadth First Search)")),(0,a.kt)("p",null,"Try to understand the iterative way of solving a DFS or BFS question and how things work. There are 3 basic things"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Push the first node"),(0,a.kt)("li",{parentName:"ul"},"Iterate over all nodes (first time it\u2019s just the root)"),(0,a.kt)("li",{parentName:"ul"},"Pop the top element"),(0,a.kt)("li",{parentName:"ul"},"Add the neighbors"),(0,a.kt)("li",{parentName:"ul"},"Repeat (Usually through the while or for loop)\nHere\u2019s a beautiful visualization of a search in a tree: ",(0,a.kt)("a",{parentName:"li",href:"https://algorithm-visualizer.org/branch-and-bound/depth-limited-search"},"Branch and Bound - Depth-Limited Search"))),(0,a.kt)("p",null,"Here\u2019s a general iterative dfs pseudo-code template:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"def dfs(root, target):\n stack = []\n stack.append(root) # add the first item\n\n while len(stack)>0:\n node = stack.pop() # pop the grid item\n\n if(node == target):\n return true\n\n # explore more\n # For trees -> if root.left or root.right\n if (condition):\n stack.append(new_item)\n\n return false;\n")),(0,a.kt)("p",null,"The second step is that of ",(0,a.kt)("strong",{parentName:"p"},"MEMOIZATION")," and we want to keep a track of all the nodes visited when\nwe\u2019re iterating over. Here\u2019s a complete version of a BFS algorithm where we keep track of the visited node using an array ",(0,a.kt)("strong",{parentName:"p"},"discovered []"),"\nThis could be anything - array, map, set - depending on the situation. The only thing we need is to store the visited things so that we\u2019re not repeating any work."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'public static void BFS(Graph graph, int v, boolean[] discovered)\n {\n // create a queue for doing BFS\n Queue<Integer> q = new ArrayDeque<>();\n // mark the source vertex as discovered\n discovered[v] = true;\n // enqueue source vertex\n q.add(v);\n // loop till queue is empty\n while (!q.isEmpty())\n {\n // deque front node and print it\n v = q.poll();\n System.out.print(v + " ");\n // do for every edge `v --\x3e u`\n for (int u: graph.adjList.get(v))\n {\n if (!discovered[u])\n {\n // mark it as discovered and enqueue it\n discovered[u] = true;\n q.add(u);\n }\n }\n }\n }\n')),(0,a.kt)("p",null,"Trying to think of a recursive way to do this is also very important. We call dfs for every node after exploring the neighbors and can do that in a couple of ways -> inside the for loop or outside the for loop after adding the neighbors to a list. Here\u2019s an approach, also linking other approaches below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'public static void recursiveBFS(Graph graph, Queue<Integer> q,\n boolean[] discovered)\n{\n if (q.isEmpty()) {\n return;\n }\n // deque front node and print it\n int v = q.poll();\n System.out.print(v + " ");\n // do for every edge `v --\x3e u`\n for (int u: graph.adjList.get(v))\n {\n if (!discovered[u])\n {\n    // mark it as discovered and enqueue it\n discovered[u] = true;\n q.add(u);\n }\n }\n recursiveBFS(graph, q, discovered);\n}\n')),(0,a.kt)("p",null,"Other recursive ways: ",(0,a.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/"},"Depth First Search or DFS for a Graph")),(0,a.kt)("p",null,"Why are we discussing how to implement a simple search algorithm? Because this is the fundamental solution to many problems. Many graph problems require you to know dfs, bfs, and this is one of those things that is usually used in conjunction with other things. For example, suppose you have a 2D matrix with something inside it and you want to find the shortest path -> boom, BFS. Or perhaps you have a graph and want to find the vertex -> DFS/BFS. So it takes many forms, and it's critical to fully comprehend it before proceeding."),(0,a.kt)("p",null,"Here are some implementations and use cases for DFS, BFS:\nDFS:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Find connected components in a graph"),(0,a.kt)("li",{parentName:"ul"},"Calculate the vertex or edges in a graph"),(0,a.kt)("li",{parentName:"ul"},"Whether the graph is strongly connected or not"),(0,a.kt)("li",{parentName:"ul"},"Wherever you want to explore everything or maybe go in depth  ")),(0,a.kt)("p",null,"BFS"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Shortest path algorithms and questions"),(0,a.kt)("li",{parentName:"ul"},"Ford fulkerson algorithm"),(0,a.kt)("li",{parentName:"ul"},"Finding nodes in a graph"),(0,a.kt)("li",{parentName:"ul"},"Wherever there is a shortest thing, finding something quickly, etc.")),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://medium.com/leetcode-patterns/leetcode-pattern-1-bfs-dfs-25-of-the-problems-part-1-519450a84353"}," Leetcode patterns 1")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://medium.com/leetcode-patterns/leetcode-pattern-2-dfs-bfs-25-of-the-problems-part-2-a5b269597f52"}," Leetcode Patterns 2")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.techiedelight.com/depth-first-search-dfs-vs-breadth-first-search-bfs/"}," Depth-First Search (DFS) vs Breadth-First Search (BFS) \u2013 Techie Delight"))),(0,a.kt)("h2",{id:"questions"},"Questions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/flood-fill/"}," Flood Fill")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/binary-tree-preorder-traversal/"},"Leetcode - Binary Tree Preorder Traversal")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/number-of-islands/"},"Number of Islands")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/walls-and-gates/"},"Walls and Gates")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/max-area-of-island/"},"Max Area of Island")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/number-of-provinces/description/"},"Number of Provinces")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/perfect-squares/"},"279. Perfect Squares")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/course-schedule/"},"Course Schedule")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/detect-cycle-undirected-graph/"},"C/C++ Program for Detect cycle in an undirected graph")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/word-ladder/"},"127. Word Ladder")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/01-matrix/"},"542. 01 Matrix")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/rotting-oranges/"},"Rotting Oranges")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/perfect-squares/"},"279. Perfect Squares")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/all-paths-from-source-to-target/"},"797. All Paths From Source to Target")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/number-of-closed-islands/"},"1254. Number of Closed Islands"))))}u.isMDXComponent=!0}}]);