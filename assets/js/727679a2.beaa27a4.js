"use strict";(self.webpackChunkskydev=self.webpackChunkskydev||[]).push([[7467],{3905:(e,t,o)=>{o.d(t,{Zo:()=>p,kt:()=>d});var n=o(7294);function i(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function m(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){i(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function a(e,t){if(null==e)return{};var o,n,i=function(e,t){if(null==e)return{};var o,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||(i[o]=e[o]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}var l=n.createContext({}),s=function(e){var t=n.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):m(m({},t),e)),o},p=function(e){var t=s(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var o=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),c=s(o),d=i,u=c["".concat(l,".").concat(d)]||c[d]||h[d]||r;return o?n.createElement(u,m(m({ref:t},p),{},{components:o})):n.createElement(u,m({ref:t},p))}));function d(e,t){var o=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=o.length,m=new Array(r);m[0]=c;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a.mdxType="string"==typeof e?e:i,m[1]=a;for(var s=2;s<r;s++)m[s]=o[s];return n.createElement.apply(null,m)}return n.createElement.apply(null,o)}c.displayName="MDXCreateElement"},8350:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>m,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>s});var n=o(7462),i=(o(7294),o(3905));const r={},m=void 0,a={unversionedId:"OOPS/Polymorphism",id:"OOPS/Polymorphism",title:"Polymorphism",description:"What is Polymorphism?",source:"@site/docs/OOPS/Polymorphism.md",sourceDirName:"OOPS",slug:"/OOPS/Polymorphism",permalink:"/Skydev/docs/OOPS/Polymorphism",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Object",permalink:"/Skydev/docs/OOPS/Object"},next:{title:"Problems",permalink:"/Skydev/docs/OOPS/Problems"}},l={},s=[{value:"What is Polymorphism?",id:"what-is-polymorphism",level:2},{value:"Compile Time Polymorphism:",id:"compile-time-polymorphism",level:5},{value:"Runtime Polymorphism:",id:"runtime-polymorphism",level:5}],p={toc:s};function h(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"what-is-polymorphism"},"What is Polymorphism?"),(0,i.kt)("p",null,"Polymorphism is composed of two words - \u201cpoly\u201d which means \u201cmany\u201d, and \u201cmorph\u201d\nwhich means \u201cshapes\u201d. Therefore Polymorphism refers to something that has many\nshapes.\nIn OOPs, Polymorphism refers to the process by which some code, data, method, or\nobject behaves differently under different circumstances or contexts. Compile-time\npolymorphism and Run time polymorphism are the two types of polymorphisms in\nOOPs languages."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"What is Compile time Polymorphism and how is it different\nfrom Runtime Polymorphism?\nCompile Time Polymorphism: Compile time polymorphism, also known as Static\nPolymorphism, refers to the type of Polymorphism that happens at compile time.\nWhat it means is that the compiler decides what shape or value has to be taken by\nthe entity in the picture.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class CompileTimePolymorphism{\n// 1st method with name add\npublic int add(int x, int y){\nreturn x+y;\n}\n// 2nd method with name add\npublic int add(int x, int y, int z){\nreturn x+y+z;\n}\n// 3rd method with name add\npublic int add(double x, int y){\nreturn (int)x+y;\n}\n// 4th method with name add\npublic int add(int x, double y){\nreturn x+(int)y;\n}\n}\nclass Test{\npublic static void main(String[] args){\nCompileTimePolymorphism demo=new CompileTimePolymorphism();\n// In the below statement, the Compiler looks at the argument types and decides to c\nSystem.out.println(demo.add(2,3));\n// Similarly, in the below statement, the compiler calls method 2\nSystem.out.println(demo.add(2,3,4));\n// Similarly, in the below statement, the compiler calls method 4\nSystem.out.println(demo.add(2,3.4));\n// Similarly, in the below statement, the compiler calls method 3\nSystem.out.println(demo.add(2.5,3));\n}\n}\n")),(0,i.kt)("p",null,"In the above example, there are four versions of add methods. The first method takes\ntwo parameters while the second one takes three. For the third and fourth methods,\nthere is a change of order of parameters. The compiler looks at the method signature\nand decides which method to invoke for a particular method call at compile time.\nRuntime Polymorphism: Runtime polymorphism, also known as Dynamic\nPolymorphism, refers to the type of Polymorphism that happens at the run time.\nWhat it means is it can't be decided by the compiler. Therefore what shape or value\nhas to be taken depends upon the execution. Hence the name Runtime\nPolymorphism."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class AnyVehicle{\npublic void move(){\nSystem.out.println(\u201cAny vehicle should move!!\u201d);\n}\n}\nclass Bike extends AnyVehicle{\npublic void move(){\nSystem.out.println(\u201cBike can move too!!\u201d);\n}\n}\nclass Test{\npublic static void main(String[] args){\nAnyVehicle vehicle = new Bike();\n// In the above statement, as you can see, the object vehicle is of type AnyVehicle\n// But the output of the below statement will be \u201cBike can move too!!\u201d,\n// because the actual implementation of object \u2018vehicle\u2019 is decided during runtime v\nvehicle = new AnyVehicle();\n// Now, the output of the below statement will be \u201cAny vehicle should move!!\u201d,\nvehicle.move();\n}\n}\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"How does C++ support Polymorphism?\nC++ is an Object-oriented programming language and it supports Polymorphism as\nwell:")),(0,i.kt)("h5",{id:"compile-time-polymorphism"},"Compile Time Polymorphism:"),(0,i.kt)("p",null,"C++ supports compile-time polymorphism with\nthe help of features like templates, function overloading, and default\narguments."),(0,i.kt)("h5",{id:"runtime-polymorphism"},"Runtime Polymorphism:"),(0,i.kt)("p",null,"C++ supports Runtime polymorphism with the help of\nfeatures like virtual functions. Virtual functions take the shape of the functions\nbased on the type of object in reference and are resolved at runtime."),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"What is meant by static polymorphism?\nStatic Polymorphism is commonly known as the Compile time polymorphism. Static\npolymorphism is the feature by which an object is linked with the respective function\nor operator based on the values during the compile time. Static or Compile time\nPolymorphism can be achieved through Method overloading or operator\noverloading.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"What is meant by dynamic polymorphism?\nDynamic Polymorphism or Runtime polymorphism refers to the type of\nPolymorphism in OOPs, by which the actual implementation of the function is\ndecided during the runtime or execution. The dynamic or runtime polymorphism can\nbe achieved with the help of method overriding."))))}h.isMDXComponent=!0}}]);