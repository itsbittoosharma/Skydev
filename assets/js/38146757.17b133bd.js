"use strict";(self.webpackChunkskydev=self.webpackChunkskydev||[]).push([[6238],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>p});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),d=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(r),p=i,f=u["".concat(s,".").concat(p)]||u[p]||h[p]||a;return r?n.createElement(f,o(o({ref:t},c),{},{components:r})):n.createElement(f,o({ref:t},c))}));function p(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<a;d++)o[d]=r[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},9998:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var n=r(7462),i=(r(7294),r(3905));const a={sidebar_position:16},o="Tries",l={unversionedId:"DSA/Tries",id:"DSA/Tries",title:"Tries",description:"Introduction",source:"@site/docs/DSA/Tries.md",sourceDirName:"DSA",slug:"/DSA/Tries",permalink:"/docs/DSA/Tries",draft:!1,tags:[],version:"current",sidebarPosition:16,frontMatter:{sidebar_position:16},sidebar:"tutorialSidebar",previous:{title:"Priority Queue",permalink:"/docs/DSA/Priority_Queue"},next:{title:"Additional Topics",permalink:"/docs/DSA/Additional_Topics"}},s={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Implement Trie",id:"implement-trie",level:2},{value:"Insert",id:"insert",level:3},{value:"Searching",id:"searching",level:3},{value:"Starts With",id:"starts-with",level:3},{value:"Resources",id:"resources",level:2},{value:"Questions",id:"questions",level:2}],c={toc:d};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tries"},"Tries"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Tries are also a type of prefix trees which are tree-like structures to store strings. Let's start with a question: You have 2 strings and we want to find the common letters in it. The first brute force way is to iterate over the first string, add the letters to a set -> then iterate over the\nnext string and see all the elements that are in the set. You could also do things like string2.contains(char) -> but it\u2019s the same thing wrt time complexity.\nWe can insert and find strings in O(L) time, where L is the length of the string. Another use case can be to print the characters in order. "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Tries",src:r(8964).Z,width:"311",height:"286"})),(0,i.kt)("h2",{id:"implement-trie"},"Implement Trie"),(0,i.kt)("p",null,"We\u2019re going to implement the trie here and understand how it works. A lot of times -> you would have to implement this on the side and then use it in a question, so we\u2019re going to discuss a question as well. At the same time, the question could also be \u201csearch for a letter\u201d -> where we can just use the search function.  "),(0,i.kt)("p",null,"First, we want to decide how the Node class looks like. Every node needs to hold a map of the children and a boolean which tells if it is the last node (leaf node / last character):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class TrieNode:\n def __init__(self):\n self.children = {}\n self.isLast = False\n")),(0,i.kt)("p",null,"We need the Trie class now. The major functions are insert, search, startsWith -> where we can also add more -> delete, findChar, etc. Let\u2019s begin the insert function."),(0,i.kt)("h3",{id:"insert"},"Insert"),(0,i.kt)("p",null,"We want to insert a character at the very end of the trie. The first part of that is iterating down and finding the last character (through the isLast field of TrieNode) and then add the character to the map.\nThe letter which we\u2019ll add will be a TrieNode() and not just a character. Every node is a TrieNode -> which has those 2 things.",(0,i.kt)("br",{parentName:"p"}),"\n","Here\u2019s how we do it"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Iterate over the word - every letter"),(0,i.kt)("li",{parentName:"ul"},"Iterating forward -> node = node.children","[letter]"),(0,i.kt)("li",{parentName:"ul"},"We add the letter there -> node.children","[letter]"," = TrieNode()")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"def insert(self, word):\n node = self.root\n for letter in word:\n if letter not in node.children:\n node.children[letter] = TrieNode()\n\n node = node.children[letter]\n\n node.isLast = True\n")),(0,i.kt)("h3",{id:"searching"},"Searching"),(0,i.kt)("p",null,"We want to search for a character or stream of characters in a string.\nHere are the steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Iterate over the letters"),(0,i.kt)("li",{parentName:"ul"},"If the letter is not in node.children -> return false. Remember, node.children is a dictionary of the letter mappings for the children, -> so it should be there."),(0,i.kt)("li",{parentName:"ul"},"Iterating forward -> node = node.children","[letter]"),(0,i.kt)("li",{parentName:"ul"},"If we reach the end without returning false, we return if it\u2019s the last element or not -> using the isLast class field.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\ndef search(self, word):\n node = self.root\n for letter in word:\n if letter not in node.children:\n return False\n\n node = node.children[letter]\n return node.isLast\n")),(0,i.kt)("h3",{id:"starts-with"},"Starts With"),(0,i.kt)("p",null," We want to return true if the string (prefix) is at the start of a word. We can simply use the class field to our advantage and find the right answer here.\nHere are the steps"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Iterate over the letters"),(0,i.kt)("li",{parentName:"ul"},"If the letter is not in node.children -> return false. Remember, node.children is a dictionary of the letter mappings for the children, -> so it should be there."),(0,i.kt)("li",{parentName:"ul"},"Iterating forward -> node = node.children","[letter]")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"def startsWith(self, prefix):\n node = self.root\n for letter in prefix:\n if letter not in node.children:\n return False\n node = node.children[letter]\n return True\n")),(0,i.kt)("h2",{id:"resources"},"Resources"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://youtu.be/7XmS8McW_1U"},"- Trie Data Structure - Beau teaches JavaScript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://youtu.be/giiaIofn31A"},"- Trie Data Structure Implementation (LeetCode) "))),(0,i.kt)("h2",{id:"questions"},"Questions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/implement-trie-prefix-tree/"},"Leetcode 208. Implement Trie (Prefix Tree)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/word-break/"},"Leetcode 139. Word Break")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/word-break-ii/"},"Leetcode Word Break II")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/word-search-ii/"},"Leetcode 212. Word Search II")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/stream-of-characters/"},"Leetcode 1032 Stream of Characters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/"},"Leetcode 421 Maximum Xor of Two Numbers in an Array"))))}h.isMDXComponent=!0},8964:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Tries-0a7f7de0517fa8c135fddd8dff766baf.png"}}]);