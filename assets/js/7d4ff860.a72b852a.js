"use strict";(self.webpackChunkskydev=self.webpackChunkskydev||[]).push([[4982],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var m=a.createContext({}),l=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(m.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,m=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(n),p=o,u=d["".concat(m,".").concat(p)]||d[p]||h[p]||r;return n?a.createElement(u,i(i({ref:t},c),{},{components:n})):a.createElement(u,i({ref:t},c))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var m in t)hasOwnProperty.call(t,m)&&(s[m]=t[m]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9977:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:17},i="Additional Topics",s={unversionedId:"OOPS/Introduction",id:"OOPS/Introduction",title:"Additional Topics",description:"Introduction",source:"@site/docs/OOPS/Introduction.md",sourceDirName:"OOPS",slug:"/OOPS/Introduction",permalink:"/Skydev/docs/OOPS/Introduction",draft:!1,tags:[],version:"current",sidebarPosition:17,frontMatter:{sidebar_position:17},sidebar:"tutorialSidebar",previous:{title:"OOPS",permalink:"/Skydev/docs/category/oops"},next:{title:"Abstract Class",permalink:"/Skydev/docs/OOPS/Abstract Class"}},m={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Now, these paradigms can be further classified based:",id:"now-these-paradigms-can-be-further-classified-based",level:2},{value:"Compile Time Polymorphism:",id:"compile-time-polymorphism",level:5},{value:"Runtime Polymorphism:",id:"runtime-polymorphism",level:5}],c={toc:l};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"additional-topics"},"Additional Topics"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"OOPs, or Object-Oriented Programming is a programming model or paradigm which\nrevolves around the concept of \u201cOBJECTS\u201d. Objects can be considered as real-world\ninstances of entities like class, that contain some characteristics and behaviors\nspecified in the class template.\nIn simple language, a class can be considered as the blueprint or template, based on\nwhich objects can be created. So the Objects are considered the instance of a class,\nand are therefore sometimes called \u201cinstances\u201d. The term \u201ccharacteristics\u201d refers to\nthe \u201cwhat\u201d about the Object, and the term \u201cbehavior\u201d refers to the \u201chow\u201d about the\nObject."),(0,o.kt)("p",null,"Characteristics are also known as data, attributes, or properties, and Behaviours are\nalso known as the functions, procedures or methods, in the programming language.\nThe concept of \u201cobjects\u201d allows the OOPs model to easily access, use and modify the\ninstance data and methods, interact with other objects, and define methods in\nruntime (during the execution of the program). This gives the OOPs model\nsignificance and makes it diverse in its implementation.\nIn fact, the OOPs model is so popular, that many of the most widely used\nprogramming languages support and use this Object Oriented Programming or OOPs\nmodel, such as Java, C++, Python, C#, etc."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"What is meant by the term OOPs?\nOOPs refers to Object-Oriented Programming. It is the programming paradigm that is\ndefined using objects. Objects can be considered as real-world instances of entities\nlike class, that have some characteristics and behaviors."),(0,o.kt)("li",{parentName:"ol"},"What is the need for OOPs?\nThere are many reasons why OOPs is mostly preferred, but the most important\namong them are:\nOOPs helps users to understand the so3. What are some major Object Oriented Programming\nlanguages?"),(0,o.kt)("li",{parentName:"ol"},"What are some major Object Oriented Programming\nlanguages?\nThe programming languages that use and follow the Object-Oriented Programming\nparadigm or OOPs, are known as Object-Oriented Programming languages. Some of\nthe major Object-Oriented Programming languages include:\nJava\nC++\nJavascript\nPython\nPHP\nAnd many more."),(0,o.kt)("li",{parentName:"ol"},"What are some other programming paradigms other than\nOOPs?\nProgramming paradigms refers to the method of classification of programming\nlanguages based on their features. There are mainly two types of Programming\nParadigms:\nImperative Programming Paradigm\nDeclarative Programming Paradigm")),(0,o.kt)("h2",{id:"now-these-paradigms-can-be-further-classified-based"},"Now, these paradigms can be further classified based:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Imperative Programming Paradigm: Imperative programming focuses on HOW\nto execute program logic and defines control flow as statements that change a\nprogram state. This can be further classified as:\na) Procedural Programming Paradigm: Procedural programming specifies the steps a\nprogram must take to reach the desired state, usually read in order from top to\nbottom.\nb) Object-Oriented Programming or OOP: Object-oriented programming (OOP)\norganizes programs as objects, that contain some data and have some behavior.\nc) Parallel Programming: Parallel programming paradigm breaks a task into subtasks\nand focuses on executing them simultaneously at the same time."),(0,o.kt)("li",{parentName:"ol"},"Declarative Programming Paradigm: Declarative programming focuses on WHAT\nto execute and defines program logic, but not a detailed control flow. Declarative\nparadigm can be further classified into:\na) Logical Programming Paradigm: Logical programming paradigm is based on\nformal logic, which refers to a set of sentences expressing facts and rules about how\nto solve a problem\nb) Functional Programming Paradigm: Functional programming is a programming\nparadigm where programs are constructed by applying and composing functions.\nc) Database Programming Paradigm: Database programming model is used to\nmanage data and information structured as fields, records, and files."),(0,o.kt)("li",{parentName:"ol"},"What is meant by Structured Programming?\nStructured Programming refers to the method of programming which consists of a\ncompletely structured control flow. Here structure refers to a block, which contains a\nset of rules, and has a definitive control flow, such as (if/then/else), (while and for),\nblock structures, and subroutines.\nNearly all programming paradigms include Structured programming, including the\nOOPs model."),(0,o.kt)("li",{parentName:"ol"},"What are the main features of OOPs?\nOOPs or Object Oriented Programming mainly comprises of the below four features,\nand make sure you don't miss any of these:\nInheritance\nEncapsulation\nPolymorphism\nData Abstraction"),(0,o.kt)("li",{parentName:"ol"},"What are some advantages of using OOPs?\nOOPs is very helpful in solving very complex level of problems.\nHighly complex programs can be created, handled, and maintained easily using\nobject-oriented programming.\nOOPs, promote code reuse, thereby reducing redundancy.\nOOPs also helps to hide the unnecessary details with the help of Data\nAbstraction.\nOOPs, are based on a bottom-up approach, unlike the Structural programming\nparadigm, which uses a top-down approach.\nPolymorphism offers a lot of flexibility in OOPs."),(0,o.kt)("li",{parentName:"ol"},"Why is OOPs so popular?\nOOPs programming paradigm is considered as a better style of programming. Not\nonly it helps in writing a complex piece of code easily, but it also allows users to\nhandle and maintain them easily as well. Not only that, the main pillar of OOPs - Data\nAbstraction, Encapsulation, Inheritance, and Polymorphism, makes it easy for\nprogrammers to solve complex scenarios. As a result of these, OOPs is so popular."),(0,o.kt)("li",{parentName:"ol"},"What is a class?\nA class can be understood as a template or a blueprint, which contains some values,\nknown as member data or member, and some set of rules, known as behaviors or\nfunctions. So when an object is created, it automatically takes the data and functions\nthat are defined in the class.\nTherefore the class is basically a template or blueprint for objects. Also one can\ncreate as many objects as they want based on a class.\nFor example, first, a car\u2019s template is created. Then multiple units of car are created\nbased on that template."),(0,o.kt)("li",{parentName:"ol"},"What is an object?\nAn object refers to the instance of the class, which contains the instance of the\nmembers and behaviors defined in the class template. In the real world, an object is\nan actual entity to which a user interacts, whereas class is just the blueprint for that\nobject. So the objects consume space and have some characteristic behavior.\nFor example, a specific car."),(0,o.kt)("li",{parentName:"ol"},"What is encapsulation?\nOne can visualize Encapsulation as the method of putting everything that is required\nto do the job, inside a capsule and presenting that capsule to the user. What it means\nis that by Encapsulation, all the necessary data and methods are bind together and\nall the unnecessary details are hidden to the normal user. So Encapsulation is the\nprocess of binding data members and methods of a program together to do a specific\njob, without revealing unnecessary details.\nEncapsulation can also be defined in two different ways:\n1) Data hiding: Encapsulation is the process of hiding unwanted information, such as\nrestricting access to any member of an object.\n2) Data binding: Encapsulation is the process of binding the data members and the\nmethods together as a whole, as a class."),(0,o.kt)("li",{parentName:"ol"},"What is Polymorphism?\nPolymorphism is composed of two words - \u201cpoly\u201d which means \u201cmany\u201d, and \u201cmorph\u201d\nwhich means \u201cshapes\u201d. Therefore Polymorphism refers to something that has many\nshapes.\nIn OOPs, Polymorphism refers to the process by which some code, data, method, or\nobject behaves differently under different circumstances or contexts. Compile-time\npolymorphism and Run time polymorphism are the two types of polymorphisms in\nOOPs languages."),(0,o.kt)("li",{parentName:"ol"},"What is Compile time Polymorphism and how is it different\nfrom Runtime Polymorphism?\nCompile Time Polymorphism: Compile time polymorphism, also known as Static\nPolymorphism, refers to the type of Polymorphism that happens at compile time.\nWhat it means is that the compiler decides what shape or value has to be taken by\nthe entity in the picture.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"class CompileTimePolymorphism{\n// 1st method with name add\npublic int add(int x, int y){\nreturn x+y;\n}\n// 2nd method with name add\npublic int add(int x, int y, int z){\nreturn x+y+z;\n}\n// 3rd method with name add\npublic int add(double x, int y){\nreturn (int)x+y;\n}\n// 4th method with name add\npublic int add(int x, double y){\nreturn x+(int)y;\n}\n}\nclass Test{\npublic static void main(String[] args){\nCompileTimePolymorphism demo=new CompileTimePolymorphism();\n// In the below statement, the Compiler looks at the argument types and decides to c\nSystem.out.println(demo.add(2,3));\n// Similarly, in the below statement, the compiler calls method 2\nSystem.out.println(demo.add(2,3,4));\n// Similarly, in the below statement, the compiler calls method 4\nSystem.out.println(demo.add(2,3.4));\n// Similarly, in the below statement, the compiler calls method 3\nSystem.out.println(demo.add(2.5,3));\n}\n}\n")),(0,o.kt)("p",null,"In the above example, there are four versions of add methods. The first method takes\ntwo parameters while the second one takes three. For the third and fourth methods,\nthere is a change of order of parameters. The compiler looks at the method signature\nand decides which method to invoke for a particular method call at compile time.\nRuntime Polymorphism: Runtime polymorphism, also known as Dynamic\nPolymorphism, refers to the type of Polymorphism that happens at the run time.\nWhat it means is it can't be decided by the compiler. Therefore what shape or value\nhas to be taken depends upon the execution. Hence the name Runtime\nPolymorphism."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"class AnyVehicle{\npublic void move(){\nSystem.out.println(\u201cAny vehicle should move!!\u201d);\n}\n}\nclass Bike extends AnyVehicle{\npublic void move(){\nSystem.out.println(\u201cBike can move too!!\u201d);\n}\n}\nclass Test{\npublic static void main(String[] args){\nAnyVehicle vehicle = new Bike();\n// In the above statement, as you can see, the object vehicle is of type AnyVehicle\n// But the output of the below statement will be \u201cBike can move too!!\u201d,\n// because the actual implementation of object \u2018vehicle\u2019 is decided during runtime v\nvehicle = new AnyVehicle();\n// Now, the output of the below statement will be \u201cAny vehicle should move!!\u201d,\nvehicle.move();\n}\n}\n")),(0,o.kt)("ol",{start:14},(0,o.kt)("li",{parentName:"ol"},"How does C++ support Polymorphism?\nC++ is an Object-oriented programming language and it supports Polymorphism as\nwell:")),(0,o.kt)("h5",{id:"compile-time-polymorphism"},"Compile Time Polymorphism:"),(0,o.kt)("p",null,"C++ supports compile-time polymorphism with\nthe help of features like templates, function overloading, and default\narguments."),(0,o.kt)("h5",{id:"runtime-polymorphism"},"Runtime Polymorphism:"),(0,o.kt)("p",null,"C++ supports Runtime polymorphism with the help of\nfeatures like virtual functions. Virtual functions take the shape of the functions\nbased on the type of object in reference and are resolved at runtime."),(0,o.kt)("ol",{start:15},(0,o.kt)("li",{parentName:"ol"},"What is meant by Inheritance?\nThe term \u201cinheritance\u201d means \u201creceiving some quality or behavior from a parent to\nan offspring.\u201d In object-oriented programming, inheritance is the mechanism by\nwhich an object or class (referred to as a child) is created using the definition of\nanother object or class (referred to as a parent). Inheritance not only helps to keep\nthe implementation simpler but also helps to facilitate code reuse."),(0,o.kt)("li",{parentName:"ol"},"What is Abstraction?\nIf you are a user, and you have a problem statement, you don't want to know how the\ncomponents of the software. If you are a user, and you have a problem statement, you don't want to know how the\ncomponents of the so")))}h.isMDXComponent=!0}}]);